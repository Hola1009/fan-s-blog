> [!summary]
redis 在其中起到的作用是:
> - 使用 redis set 的特性来查询共同关注的用户
> - 用来做 Feed 流收件箱

## 关注和取关
### 表结构
用户之间的关注关系可以用一张表保存起来, 表字段如下
- id
- 用户id
- 关注用户 id
- 创建时间
### 功能实现
实现两个接口
1. 关注和取关 接口
2. 判断是否关注 接口

## 共同关注
需要找到两个集合中的交集, redis 恰好有合适的数据结构来查找交集, 既是 `set`, set 是有求交集的操作的
```bash
sadd s1 v1 v2
>> 2
sadd s2 v2 v3
>> 2
sinter s1 s2
>> "v2"
```

### 功能实现
- 以用户 id 为 key, 关注的用户 ids 为 value 用 set 来存储
- 改造之前实现的两个接口, 关注和取关时操作 redis
- 判断是否关注改成从 redis 中查
- 实现查询共同关注接口

### 信息代码块
```java
// 查询
Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);

```
## 关注推送
> [!tip]
> - 关注的目的是在 up 更新笔记时能过推送粉丝
> - 关注推送也叫做 Feed 流, 为用户持续提供 "沉浸式" 体验, 通过无限下拉获取新的信息
> - 减少了用户思考和查找的过程
> ![[Pasted image 20241120112247.png]]

### Feed 流的模式
其有两种常见的模式

#### Timeline
不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈
- 优点：信息全面，不会有缺失。并且实现也相对简单
- 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低

#### 智能排序
利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户
- 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
- 缺点：如果算法不精准，可能起到反作用

### 实现方案
本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：
- 拉模式
- 推模式
- 推拉结合

#### 拉模式
up 更新时将消息保存在发件箱, 用户登录时去发件箱读取
- 优点: 节省内存
- 缺点: 耗时, 延迟高

#### 推模式
up 更新时将消息发到用户的收件箱
- 优点: 延迟低
- 缺点: 内存占用高

#### 推拉结合模式
也叫读写混合
- 对于活跃粉丝使用推模式
- 对于不活跃粉丝使用拉模式

#### 总结
![[Pasted image 20241120124752.png]]

### 功能实现
1. 修改添加笔记的业务, 在保存 blog 到数据库的同时, 推送到粉丝的收件箱
2. 收件箱满足可以根据时间戳排序, 必须用 Redis 的数据结构实现
3. 查询收件箱数据时, 可以实现分页查询

> [!question] 收件箱用什么数据结构
> 用 redis string 来存, userId 为 key, 消息 id 为 value 

> [!question] 分页问题
> 倒序查询, 随着数据不断更新, 数据角标是会发生变化的, 因此不能采用传统分页
> ```bash
> zrevrange z1 1000 0 limit 0 3
>```
> ![[Pasted image 20241120131223.png]]

采用滚动分页来解决问题, 每次记录上次查询的最后一条
第一次查
```bash
zrevrangebyscore z1 1000 0 withscores limit 0 3;
```

第二次查
```bash
# 这里 limit 后面的 1 表示偏移量
zrevrangebyscore z1 5 0 withscores limit 1 3;
```

![[Pasted image 20241120141212.png|500]]


