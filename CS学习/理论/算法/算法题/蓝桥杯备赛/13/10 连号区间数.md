# 题目描述
小明这些天一直在思考这样一个奇怪而有趣的问题：
在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：
如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为`R-L+1`的“连续”数列，则称这个区间连号区间。
当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。
输入格式：
第一行是一个正整数N (1 <= N <= 50000), 表示全排列的规模。
第二行是N个不同的数字Pi(1 <= Pi <= N)， 表示这N个数字的某一全排列。
输出格式：
输出一个整数，表示不同连号区间的数目。
示例：
> 用户输入：
> 4
> 3 2 4 1
> 程序应输出：
> 7

> 用户输入：
> 5
> 3 4 2 5 1
> 程序应输出：
> 9

解释：
第一个用例中，有7个连号区间分别是：[1,1], [1,2], [1,3], [1,4], [2,2], [3,3], [4,4]
第二个用例中，有9个连号区间分别是：[1,1], [1,2], [1,3], [1,4], [1,5], [2,2], [3,3], [4,4], [5,5]
# 代码
```java
public class Main {  
    public static void main(String[] args) {  
        Scanner scan = new Scanner(System.in);  
        int n = scan.nextInt(), result = 0;  
  
        int[] nums = new int[n];  
        for (int i = 0; i < n; i++) nums[i] = scan.nextInt();  
        for (int i = 0; i < n; i++, result++) {  
            int max = nums[i], min = nums[i];  
            for (int j = i + 1; j < n; j++) {  
                if (nums[j] < min) min = nums[j];  
                if (nums[j] > max) max = nums[j];  
                if(j - i == max - min) result++;  
            }  
        }  
        System.out.println(result);  
    }  
}
```
# 题解
用栗子1来演示
> 用户输入：
> 4
> 3 2 4 1
> 程序应输出：
> 7

![[连号区间数1|left|600]]

用i j 来表示区间的左右端, 如果区间内的`最大值于最小值的差` = `i - j` 就说明区间是连续的 
用两层循环来遍历每个区间
外层循环遍历每个左端点 有n个数就有n个左端点
内层循环遍历右端点 遍历的时候更新最大值与最小值
