每个应用程序运行于现代操作系统之上时, 操作系统会提供一种抽象, 好像系统只有这个程序在运行, 所有的硬件资源都被这个程序使用. 这种假象是通过抽象了一个进程的概念来完成的, 进程可以说是计算机中最成功的概念之一

进程是操作系统对一个正在运行的程序的一种抽象, 换言之, 可以把进程看作程序的一次运行过程;
同时,` 在操作系统内部, 进程又是操作系统进行资源分配的基本单位`

一个跑起来的程序程序就叫进程
![[Pasted image 20240113113204.png]]

这是一个应用程序 但还没跑起来 就不是一个进程
![[Pasted image 20240113113316.png|left]]
每个进程, 都是系统资源分配的基本单位

# 系统是如何对进程进行管理的
一个事物多起来了就需要管理
管理, 两个角度
1. 描述 使用类/结构体, 把被管理的一个对象, 各个属性表示出来
2. 组织 使用数据结构, 把这些表示出来的对象, 串起来(方便后续的增删改查)
> [!question] 如何管理进程
> 先描述: 使用PCB结构表示进程的各种属性
> 后组织: 使用双向链表, 把这些PCB结构给串起来

## 系统中有专门的结构体来描述进程的属性
这个结构体统称为"进程控制块"PCB

使用PCB来描述进程的属性
一个进程就可以使用一个或多个PCB来表示

系统中会使用类似于双向链表这样的数据结构来组织多个PCB
> [!tip]
> 创建新的进程, 就是创建PCB并且把PCB插入到列表中
> 销毁进程就是把PCB从链表中删除并释放
> 展示进程列表, 就相当于是遍历链表的每个节点
### PCB
PCB是一个非常庞大的结构体, 包含很多的属性
1. pid: 进程的身份标识  
	每个进程都会有一个pid, 同一时刻, 不同进程的pid是不同的
2. 内存指针
	 每个进程在运行的时候, 都会分配一定的内存空间
	 这个进程内存空间具体是哪里, 以及分配的内存空间中有哪些部分, 每个部分是干啥的
	 有这么一组指针来进行区分
	 在哪里 => 有什么部分 => 每个部分有什么用
> [!example] 
> 最典型的, 进程的内存空间, 需要有专门的区域存储执行的指令, 以及指令依赖的数据
> 同时还需要存储一些运行时产生的临时数据

3. 文件描述符 类似于顺序表这样的数据结构, 有很多元素
	和文件有关 => 硬盘有关
	一个进程也需要涉及到硬盘操作, 就需要按照文件的方式来操作
	 当前进程关联了哪些文件, 都能操作哪些文件
	 就是通过文件描述符
> [!summary] 描述了进程持有的"硬盘资源"是啥样的


# 进程持有的CPU资源如何体现
早期操作系统, 是一个"单任务操作系统", 同一时刻只有一个进程能运行
一个进程要执行, 就需要cpu来执行这上面的指令 早期的单核cpu电脑同一时刻只能执行一个进程的指令
> [!example] 可以把cpu可以类比成舞台, 进程相当于演员, 指令相当于剧本

我们用这个栗子来理解 下面两个概念
1. 分时复用: 多名演员轮流上去演独角戏
2. 并发 : 加入这些演员以特快的速度轮流上台, 轮换的速度快过人眼的刷新频率, 那么看起来就好像是同台演出似的 这就和连环画似的
如果两个进程同时在两个cpu核心上, 微观上也是"同时执行", 这个情况称为"并行"
一个cpu核心上, 通过快速轮转调度的方式, 执行多个进程, 宏观上"同时执行", 微观上有先有后吗这个情况称为"并发"

上述 `并发 `和 `并行` 在应用程序这一层, 感知不到
都是系统内部完成调度的

咱们作为普通的程序员平时也不会具体区分并发还是并行, 从编程的角度来说, 底层是并发还是并行, 对代码没啥影响... 平时也就会同时使用"并发"来指代 `并发` 和 `并行`

# 进程调度效果
PCB引入了一些属性, 用来支持操作系统实现 `进程调度` 效果
1. 进程的`状态`
2. 进程的`优先级`
3. 进程的`上下文`
4. 进程的`记账信息`

## 进程的状态
一般情况下, 进程可以随时调度
这种情况就叫"就绪状态"
进程时刻准备号, 去CPU上执行
就绪状态, 具有两种情况
1. 进程在CPU上执行
2. 虽然进程没有在CPU上执行, 但时刻准备就绪到CPU上执行

某个进程, 某种执行条件不具备, 就导致这个进程展示无法参与CPU的调度执行 => 这个进程就进入了阻塞状态
> 比如: 进程等待用户输入
## 进程的优先级

操作系统在调度多个进程的时候并非一视同仁, 有些进程会给更高的优先级, 优先调度

## 上下文
进程从CPU离开之前, 需要保持现场, 把当前CPU中各种寄存器的状态, 都记录到内存中
等到下次进程回到CPU上执行的时候, 此时就可以把保存的这些寄存器的值, 恢复回去, 进程就会沿着上次执行到的位置, 继续往后执行

[[CPU中的寄存器]]

## 寄存器
>通过优先级机制, 对不同的进程分配了不同权重的资源
  有可能会出现极端的情况, 所有的资源都给某个进程, 其他进程一点都没有捞着

记账信息, 会就当前进程持有CPU的情况在CPU中执行了多久)
就可以作为操作系统调度进程的参考依据

## 虚拟地址空间

早期的操作系统, 程序运行时分配的内存, 就是"物理内存"
其中存在的问题是
如果一个进程越界访问会直接导致其他进程崩溃

位进程提供稳定的运行环境是操作系统的基本功能

为解决这一问题
操作系统引入 "虚拟地址空间"概念, 不是直接分配物理内存, 而是分配虚拟内存空间
操作系统对于内存进行了一层抽象
![[虚拟内存空间|left|500]]
A操作某个内存中的数据, 就需要把操作的虚拟地址告诉系统
系统再把虚拟地址翻译成物理地址
再操作物理地址
> 如此, 操作系统就可以进行检查/校验了
> 就需要看看当前这个虚拟地址
> 是否顺利完成翻译
> 如果给定的虚拟地址是非法的, 是一个越界的访问, 系统就能及时发现, 并且对当前进程进行处理, 就不会波及到其他进程

通过这个方式就可以把进程之间给隔开了, 如果某个需求中, 确实就需要让多个进程相互配合, 此时就不好搞了
如此便要引入新的机制, 来实现 `进程` 之间的 通信

需要借助一个公共空间, 完成数据的交互
1. 通过文件
2. 通过网络



