一个线程就是一个"执行流", 每个线程之间都可以按照顺序执行自己的代码, 多个线程之间`"同时"`执行着多份代码.
>举个栗子:
> 比如一个售票台, 只开一个窗口, 就是单线程, 这样人多的时候售票效率就比较低, 所以在人多的时候就可以在同一个售票台多开几个售票窗口, 这多开的几个窗口就可以同时售票, 提升售票效率了
> 此时, 我们就把情况称为多线程, 将一个大任务分解成不同的小任务, 交给不同执行流就分别排队执行. 其中售票台就类比成进程, 第一个窗口类比成主线程


![[进程#进程调度效果]]

咱们之前讨论进程调度时是基于"一个进程里只有一个线程"的情况
实际上, 一个进程中, 是可以又多个线程的, 每个线程, 都是可以独立进行调度的
每一个线程, 也有 `状态, 优先级, 上下文, 记账信息` 除此之外 `pid, 内存指针, 文件描述符表` 每个同一个进程下的每个线程都是共享的

一个进程, 使用PCB表示, 一个进程可能使用一个PCB表示, 也可能使用多个PCB表示
每个PCB对应到一个线程上

> 上述结构决定了线程的特点
> 1. 每个线程都可以独立的去CPU上调度执行
> 2. 同一个进程的多个线程之间, 共用同一份内存空间, 和文件资源
> 	 创建线程的时候, 不需要重新盛情资源, 直接复用之前已经分配给进程的资源
> 	 省去了资源分配的开销, 于是创建效率就更高了

> [!summary]

进程中包含线程 => 一个进程由多个PCB表示 => 每个PCB就用来表示一个线程 => 每个线程都有自己的状态, 调度优先级,  上下文, 记账信息 => 每个线程都可以独立的去CPU上调度执行 => 这些PCB共用了同样的内存指针, pid, 文件描述符 => 创建线程(PCB)不许要申请资源 => 创建/销毁的效率更高