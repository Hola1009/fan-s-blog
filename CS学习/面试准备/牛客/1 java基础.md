### 1.1 为什么java代码可以实现一次编写, 到处运行
java编译后的代码是.class文件, 这个.class文件是需要通过java虚拟机翻译才能在机器运行的
这个jvm虚拟机可以根据不同的平台将.class文件翻译成不同平台能够运行的`机械码`,
所以不同的平台只要安装了特定的jvm虚拟机, 就可以运行所有代码了

> [!tip] 
> 个人认为有点接口模式的意思在里面
> jvm相当于一个接口, 不同平台的jvm相当于对这个接口的实现
而我要运行.class文件, 这需要调用这个jvm接口就行, 不用关注具体咋实现的

> [!info] 注意
> 1. 编译的结构是生成字节码, 不是机械码, 字节码不能直接运行, 必须通过jvm翻译成机械码才能运行
> 2. 跨平台的是java程序, 不是jvm

### 1.2 一个java文件里可以包含很多个类吗
可以, 但是只能有一个public类, 而且这个类必须和文件同名

### 1.3 说一说你对java访问权限的理解
java中有四种访问权限, public, private, protected, default
对应的修饰符 public, private, protected 还有什么都不加

在修饰方法和属性时:
- public: 代表其可以任何包下的任何类访问
- private: 只能在该类内部被访问
- protected: 不能被其他包的非子类访问
- default: 不能被其他包的类访问

在修饰类时, 只有两种访问权限
default 和 public
- 默认是 只能被同一个包下的类访问
- 加上public后就可以被其他包的类访问

### 1.4 介绍一下java的数据类型

java的数据类型包括基本数据类型和引用数据类型

基本数据类型有8个, 可以分为4个种类
分别是
整型: int short long byte
浮点型: double float
字符型: char
布尔型: boolean

引用类型 
可分为3种
数组, 类, 接口


### 1.5 int类型的数据范围是多少
int类型占4字节, 数据范围是 -2^31 ~ 2^31

### 1.6 请介绍全局变量和局部变量的区别
java中的变量可以分为成员变量和局部变量
1. 成员变量定义在类里面, 
2. 不给它赋值也有默认的初始值
3. 加了static修饰的成员变量, 就会被存储在方法区中 生命期和类是一样的
4. 不加就会存储在堆中 生命周期就和对象是一样的

1. 而局部变量是定义在方法体里面的
2. 存储在栈中, 方法调用完了, 就会被自动回收
3. 还有就是它没有初始值

> [!info] 注意
> Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员
变量
### 1.7 请介绍一下实例变量的默认值
如果是[[#引用数据类型]], 默认值就是null
如果是基本数据类型
对于整型和浮点型来说 默认值是0
对于布尔类型来说 默认值是false

### 1.8 为啥要有包装类
java是面向对象的语言, 它的涉及理念就是一切皆对象, 但是java中的基本数据类型就不是对象,
所以就整除了个包装类, 把基本数据类型包装一下, 方便程序员统一操作

 > [!tip] 拓展阅读
 Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了
一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都
可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但
实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。

### 1.9 说一说自动装箱 自动拆箱的应用场景
这里说的自动是jdk1.5以后才有的功能
有了自动装箱
我可以直接将一个基本数据类赋值给对应的包装类
有了自动装箱
我可以把一个包赚类赋值给其对应的基本数据类型

有了自动就简化了很多操作, 比如方法传参

### 1.10 如何对Integer 和 Double 类型进行判断
首先不能用 == 它们不是同一种数据类型
也不能转成字符串, 因为 Double 类型带小数点
compareTo只能对同种数据类型进行比较

整型 和 浮点型 包装类 都继承于 Number 类 Number类定义了有将数字转化成 其他数字类型的方法
所以我们可以将不同类型的包装类转成转化成同一种基本数据类型, 再进行比较

### 1.11 int和Integer有什么区别, 二者在做 == 运算时会得到什么结果

比较的时候Integer包装类会自动拆箱, 所以和比较两个正常int进行比较是一样的

### 1.12 说一说你对面向对象的理解
我觉得这种这种思想很哲学, 因为我们平常去认识一个事物, 就是以编程中对象的眼光去看的, 一个杯子, 一个盒子都是实体, 每种实体都有它们特有的属性, 和特有的使用方式. 所以使用面向对象这种思想去编程, 就会觉得很自然, 很顺畅, 得心应手那种感觉.
因为在编程得时候使用一个对象得时候, 就好像是实际中在操作一个实体似的, 它有它的属性, 有它特有的使用方式. 
这然我容易将编程与客观世界联系起来, 去解决问题


### 1.13 面向对象的三大特征
封装 继承 多态
- 封装指的是, 将对象的细节给隐藏起来, 通过一些公共的方法暴露该对象的功能
- 继承在已有的类之上创建一个新类, 新的类吸收了原有类的属性和方法, 而且还可以扩展新的能力
- 多态就是指多种形态, 编译类型与运行类型不同, 我可以把子类对象直接赋值给它的父类对象, 如果子类重写了父类的方法, 那么刚刚被赋值的那个对象的数据类型虽然是父类的, 但调用这个重写的方法还是会执行子类的方法体

### 1.14 封装的目的是什么, 为什么要封装?
封装也是对客观世界的一种模拟, 比如一台电视机, 我们只需要知道它上面的按钮可以完成换台, 调音, 开机关机 这些功能就可以了, 其他内部细节都被铁皮给封起来了,不需要关注它具体在电视机内部是咋完成的, 这么做不仅方便了看电视的人, 还保证了电视机内部的安全, 保证了它的完整性, 也方便了后续维修
对一个类或对象实现良好的封装, 可以实现一下目的
- 隐藏实现细节
- 让使用者只能通过事先预定的方法来访问数据, 从而可以从该方法里加入控制逻辑, 限制对成员变量的不合理访问
- 可进行数据检查, 从而有利于保证对象信息的安全性
- 便于修改, 提高代码的维护性
> [!拓展阅读]

### 1.15 说一说你对多态的理解
多态就是运行类型与操作类型不一致,导致出现相同类型对象调用同一个方法走的却是不同逻辑的情况 java允许直接将子类对象直接赋给父类对象, 这是这个被赋值的对象的编译类型是父类而运行类型是子类, 所以其在调用被重写的方法的时候, 走的是子类该方法的方法体, 而不是父类


### 1.16 java中的多态是怎么实现的
通过继承和重写来实现, 将重写了的子类对象赋值给父类.

### 1.17 java为什么是单继承, 为什么不能多继承

java的单继承指的是一个类只能有一个直接的父类, 不能多继承就是不能同时继承多个直接父类
之所以不能多继承,是为了避免多继承的时候产生混淆. 比如, 同时继承的两个父类含有相同的方法, 
子类在重写或调用该方法时就会迷惑

### 1.18 说一说 重写和重载的区别
重载发生在同一个类, 重载的方法之间 方法名必须相同 参数表必不相同, 
重写发发生在父子类之间, 方法名和参数表必须相同, 另外返回值类型要不大于父类的返回值类型, 抛出的异常也要不大于父类的. 如果父类的访问修饰符时private , 则子类不能将其重写

### 1.19 构造方法不能重写?
是的, 构造方法不能重写, 因为构造方法需要与类名保持同名

### 1.20 介绍一下Object类中的方法
Object类体提供了如下几个常用方法:
- Class\<?\> getClass 返回该对象的运行时类型
- boolean equels(Object obj) 判断指定对象是否与该对象相等
- int hashCode(): 返回该对象的hashCode值, 在默认情况下, object类的hashCode()方法根据该对象的地址来计算, 但很多类会重写该方法
- String toString(): 返回该对象的字符串表示

### 说一说hashCode() 和 equals() 的关系
hashCode() 用于获取哈希码(散列码), equals()用于比较两个对象是否相等, 
- 如果两个对象相同它们的哈希值必定相同
- 如果两个对象哈希值相同, 它们未必相同

> [!tip] 拓展阅读
> 在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。
当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由
于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，
HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。    
HashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位
置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则
说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，
此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，
再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等
则将其链到最后一个对象之后

### 1.22 为什么要重写hashCode() 和 equals()
Object提供的equals()方法默认是用 == 来比较的, 两个对象是同一个对象时 才返回 true, 而实际业务中, 我们通常认为两个对象的内容相同, 就认为它们相同了, 所以默认的eqauls()就没有实际价值了, 需要重写

由于hashCode() 和 equals() 具有联动关系[[1 java基础#说一说hashCode() 和 equals() 的关系]], 所以equals() 方法重写时, 通常也要将hashCode进行重写, 使得这两个方法始终满足相关的约定



### 1.23 == 和equals()的区别
==
- 对基本数据类型比较时,  比较的是两个数值是否相等
- 作用于引用数据类型时, 是比较两个对象的地址是否相等
equals()
- 没有重写是, 就是等同于 == 
- 重写是按照具体重写的逻辑来判断, 一般是比较两个对象内容是否相等

### 1.24 String类有哪些方法
String类是Java最常用的API, 它包含了大量处理字符串的方法, 比较常用的有:
- char chatAt() 返回指定索引下标的字符
- String subString(int begin, int end) 从字符串中截取出一部分子字符串
- String\[\] split(String regex): 以指定的方式分割字符串成数组
- String trim() 删除字符串前后的空格并将其返回
- int indexOf(String str)：返回子串在此字符串首次出现的索引；
- int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；
- boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；
- boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；
- String toUpperCase()：将此字符串中所有的字符大写；
- String toLowerCase()：将此字符串中所有的字符小写；
- String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；
- String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。
> [!info] **注意事项**
> String类的方法太多了，你没必要都记下来，更不需要一一列举。面试时能说出一些常用的方法，表现
出对这个类足够的熟悉就可以了。另外，建议你挑几个方法仔细看看源码实现，面试时可以重点说这几
个方法。


### 1.25 String 类可以被继承吗
String 由 final 修饰 所以不能被继承

### 1.26 说一说String和StringBuffer有什么区别
String是不可变类, 一个String对象被创建后, 包含在这个对象的字符串序列是不可改变的
StringBuffer对象则代表一个字符序列可变的字符串

### 1.27 说一说StringBuffer 和 StringBuilder有什么区别
这两个类都有共同的父类, 但StringBuiffer方法是线程安全的,  而StringBuilder则不是, 所以StringBuilder性能要高

### 1.28 使用字符串时, new 和 "" 推荐使用那种方式
- 用字符串进行初始化时, JVM会使用常量池来管理这个字符串
- 当使用new 时, jvm会先使用常量池来管理这个字符串的值, 在调用构造器来创建一个新的String对象, 新的对象将保存在堆中
new 会 多出来一个对象, 所以优先考虑使用""

### 1.29 说一说你对字符串拼接的理解
拼接字符串最常用的方式有4种, 
1. 使用+拼接字符串直接量
2. 使用StringBuilder 拼接字符串变量
3. 使用StringBuffer 拼接变量
4. String类的concat方法: 如果只是对两个字符串进行拼接, 并且包含变量, 则适合使用concat方法

###### 拓展阅读
如果使用`+`拼接字符串
- 如果拼接的时字符串直接量, 则编译器会将其直接优化成一个完整的字符串
- 如果拼接的字符串种包含变量, 则编译器会自动创建一个实例并调用append()方法 对其进行优化, 但每次拼接都会创建一个StringBufer对象
采用StringBuilder/StringBuffer拼接字符串时：
- StringBuilder/StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为 16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。
- 缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。

采用String类的concat方法拼接字符串时：
- concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。
在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，
- concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。

### 1.30 两个字符串相加的底层是如何实现的
如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一
个完整的字符串是一样的。
如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建
StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。

### 1.31 String a = "abc", 说一说这个过程会创建什么, 放在哪里?

JVM会使用常量池来管理字符串常量, 在执行语句时, jvm会先检查常量池种是否已经存在"abc", 若没有则将"abc"存入常量池, 否则就复用常量池中已有的"abc", 将其赋值给a

### 1.32 new String("abc") 是去哪里, 仅仅是在堆里吗
在执行这句话时, JVM会把"abc"先放入常量池, 然后再长创建一个String对象, 这个对象会被保存在堆中, 并且堆中对象的数据会指向常量池中的字符串常量

### 1.33 接口和抽象类有什么区别
###### 从使用方法上
相同点: 
- 都不能被实例化
- 接口的实现类或抽象类的子类都只有实现了抽象方法后才能实例化
不同点
- 接口只有定义, 不能有方法的实现, 除了java 1.8 之后的default 和static方法, 而抽象类可以有定义与实现, 方法可在丑啊ing类中实现
- 实现接口的关键字为implements, 继承抽象类的关键字是extends. 一个类可以实现多个几口, 但只能继承一个抽象类, 所以接口可以实现多继承, 但抽象类不可以
- 接口的成员变量默认是public static final, 必须经行初始化, 不能被修改, 抽象类中的成员变量默认default, 可在子类中被重新定义, 也可以重新赋值, 抽象类中的抽象方法必须被abstract修饰
###### 从接口设计上来说
- `接口体现的是一种规范,` 对于接口的实现者而言, 接口规范了是闲着必须向外提供哪些服务; 对于接口的调用者而言, 接口规定了调用者可以调用哪些服务, 以及如何调用这些服务. 当在一个程序中使用接口时, 接口是多个模块间的耦合标准; 当在多个应用程序中使用接口时, 接口是多个程序之间的通信标准
- 抽象类体现的是一种模板式设计, 抽象类作为多个子类的抽象父类,` 可以被当成系统实现构成中的中间产品`, 这个中间产品已经实现了系统的部分功能, 但这个产品依然不能当成最终产品, 必须有更进一步的完善, 这种完善可能有几种不同的方式


### 1.34 接口种可以有构造方法吗
由于接口定义的是一种规范, 因此接口里不能包含构造器和初始化定义


### 1.35 谈谈你对面向接口编程的理解
充分利用接口可以降低程序各个模块之间的耦合, 从而提高系统的可拓展性和可维护性
我认为这也是一种封装.  不同接口被实例化的方式不同, 但提供的服务都是一样的, 对于接口使用者来说, 并不需要关注这个接口是怎么被实例化的 
就比如 java的数据库接口JDBC 不同的数据库厂商是按照一套接口为java开发数据库服务的
而java在使用时, 只需按照接口的规范就行了, 如此便增加了系统的可拓展性和维护性

### 1.36 遇到过异常吗, 如何处理

1. 捕获异常
将业务代码try-catch起来, 捕获异常后按catch块中的业务逻辑去处理

2. 异常处理
在catch块中处理异常时, 应该先记录日志, 便于以后追溯这个异常, 然后根据异常的类型, 结合当前的业务情况, 进行相应的处理. 比如, 给变量赋予一个默认值, 直接返回空值, 向外抛出一个新的业务异常交给调用者处理

3. 回收资源
如果业务代码打开了某个资源, 比如数据库连接, 网络连接, 磁盘文件, 则就算异常了也要关闭这写资源, 所以要将这些关闭资源的代码放在finally块内, 无论是否发生异常finally块内的代码都会处理


### 1.37 说一说java的异常机制
关于异常处理:
在java中, 处理异常的语句由try, catch, fianlly 三部分组成. 其中, try块用于包裹业务代码, catch块用于捕获并处理某个类型的异常, finally用于回收资源. 当业务代码发生异常时, 系统会创建一个异常对象,  然后由jvm寻找可以处理这个异常的catch块, 并将异常对象交给catch块处理, 若业务代码打开了某项资源, 则可以在finally块中关闭这项资源, 因为无论是否发生异常, finally块一定会执行

关于抛出异常:
当程序出现错误时, 系统会自动抛出异常. 除此之外, java也允许程序主动抛出异常. 当业务代码中, 判断某项条成立时, 可以使用throw关键字向外抛出异常. 如果throw了 那还要在方法的参数表后面加上throws 表示将异常抛给调用它的方法

关于异常跟踪栈:
程序运行时, 进程会发生一系列方法调用, 从而形成调用栈, 异常机制会导致异常在这些方法之间出传播, 而异常传播顺序也方法的调用相反. 相当于递归的归的那个顺序, 所以最总会传到main方法, 若依然没有得到处理, 则jvm会终止程序, 并打印异常跟踪栈信息

### 1.38 请介绍java的异常接口
Throwable是异常的顶层父类, 代表所有的非正常情况, 它有两个直接子类, 一个是Exception, 另一个是Error

Error是错误, 一般是指与虚拟机相关的问题, 比如系统崩溃, 虚拟机错误, 这种错误无法恢复或不能捕获, 会直接导致应用程序中断, 对于Error, 你不能catch 也不能throws 因为根本就捕获不了

Exception 这也是见文知意就是异常, 它被分为两类, 分别是Checked异常 和 Runtime 异常. 所有的RuntimeException类及其子类的实例被称为Runtime异常; 不是被RuntimeException类及其子类的异常实例则被称为Checked异常. java认为checked异常都是可以被处理的异常, 搜易java程序必须显示处理checked异常, 如果程序没有处理checked异常, 该程序就会在编译时发生错误, 无法通过编译, runtime异常更加灵活吗, runtime异常无须显示生命抛出, 如果程序捕获Runtime异常, 可以用try-catch来处理

### 1.39 finally是无条件执行的吗?
不管程序有没有出现异常finally块中的代码都会执行, 就算在捕获异常后的catch代码块中写了return, 它都会执行

###### 注意事项
除非使用System.exit(1);来退出虚拟机, 否则其无论如何都会执行\

### 1.40 在finall中return会发生什么?
在通常情况下, 不要再finally块中使用return, throw等导致方法终止的语句, 一旦再finally块中使用了return 或者 throw 语句
它就会把把try块, catch块中的return 或 throw 语句给覆盖掉

### 1.41 说一说你对static关键字的理解
在Java类里只能包含成员变量, 方法, 构造器, 初始化块, 内部类 5种成员, 而static可以修饰成员变量, 方法, 初始化块, 内部类
, 以static修饰的成员就是类成员. 类成员属于整个类, 而不属于单个对象

对static关键字而言, 有一条非常重要的规则: 类成员 不能访问实例化成员, 因为类成员是属于类的, `类成员的作用域比实例成员的所用域大 ` 

### 1.42 static 修饰的类能不能被继承
static修饰的类可以被继承
###### 拓展阅读
如果使用static来修饰一个内部类, 则整个内部类就属于外部类本身, 而不属于外部类的某个对象. 因此使用static修饰的内部类被称为类内部类, 也可以叫静态内部类

### 1.43 static 和 final 有什么区别
修饰的东西不完全一样, static 可以修饰 类的属性, 方法, 代码块, 内部类
final能修饰 类 类的属性和方法
它们还有不一样的就是
被static修饰的方法可以被重写, final不行
被static修饰的属性可以被重新赋值, final就不行
还有就是 被final修饰的类不能被继承

### 1.44 说一说你对泛型的理解

java集合有个缺点一把一个对象"丢进"集合之后, 集合就会"忘记"这个对象的数据类型, 当再次取出该对象时, 该对象的编译类型就变成了Object

java集合之所以设计成这样, 是因为集合的设计者不知道我们会用集合来保存什么类型的对象, 所以它们把集合设计成能保存任何类型的对象, 只要求具有更好的通用性, 但这样带来了如下两个问题
- 集合对元素类型没有任何限制, 这样可能引发一些问题, 例如创建了一个只能放A类的集合, 却丢了一个B类对象进去
- 由于把对象丢尽集合时, 集合失去了对象的状态信息, 只知道它承装的时Object, 因此取出集合元素后通常还要进行强转, 这种强转可能会引发异常;
从java 5, java引入了"参数化类型"的概念, 允许程序在创建集合时指定集合元素类型, java的参数化类型被称为泛型, 
例如List\<String\> 表明该list只能保存字符串类型的对象
有了泛型以后, 程序再也不能"不小心"地把其他对象丢尽集合, 取元素时也不用进行强转

有了范围, 在为一个类增加通用性的基础上, 还为它增加了一层安全保障, 和便捷操作

### 1.45 介绍一下泛型擦除
在严格的泛型代码里, 带泛型申明的类总应该带着类型参数. 但为了也与老java代码保持一致, 也允许在使用带泛型申明的类
类时不指定实际的类型, 如果没有为这个泛型类指定实际的类型, 此时被称为row type, 默认是申明该泛型形参时指定的第一个上线类型
当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时, 所有在尖括号之间的类型信息都将被扔掉

### 1.46 List\<? super T\> 和 List\<? extends T\>有什么区别

- ? 是通配符, List\<?\> 可以被各种泛型List赋值
- List\<? super T\> 中的T指定了通配符的下限制, 它可以被泛型为T父类的对象赋值
- List\<? extends T\> 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的
子类型

### 1.47 说一说你对java反射机制的理解
java程序中的对象在运行时可以表现成两种类型, 即编译类型和运行类型. 有时, 程序在运行时接收到外部传入的一个对象, 该对象的编译类型是Object, 但程序又需要调用该程序的运行时类型的方法, 这时需要程序在运行时发现对象和类的真是信息, 而解决这个问题
有两种做法:
- 第一种做法时假设在编译时和运行时都知道类型的具体信息, 那么就可以使用 instanceof 来进行测试, 测试为真就进行强转
- 第二种做法时编译时根本无法判断该对象的类, 长须只艺考运行时信息来发现该对象和类的真实信息, 就必须使用反射
具体来说，通过反射机制，我们可以实现如下的操作：
- 程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；
- 程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；
- 程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。

### 1.48 java反射在实际项目中有哪些应用场景
java的反射机制在实际项目中应用广泛, 常见的应用场景有:
- 使用JDBC时, 如果要创建数据库的连接, 则需要通过反射机制加载数据库的驱动程序
- 多数框架都支持注解/xml配置, 从配置中解析出来的类就是字符串, 需要利用反射机制实例化
- 面向切面的变成(AOP)的实现方案, 是在程序运行时创建目标对象的代理类, 这必须由反射机制来实现

### 说一说java的四种引用方式
java对象的四种引用方式分贝为强引用, 软引用, 弱引用, 虚引用, 具体含义如下:
- 强引用: 这是java程序中最常用的引用方式, 即程序创建一个对象, 并把这个对象给赋给一个一个引用变量, 程序通过该引用变量来操作实际对象. 当一个对象被另一个或一个以上的变量引用时, 它便可达到该状态, 不可能被系统垃圾回收机制回收
- 软引用: 当一个对象只有软引用时, 它有可能被垃圾回收机制回收, 对于只有软引用的对象而言, 当系统内存空间足够时, 它不会被系统回收, 程序也可以使用该对下昂很难过, 当陈旭内存空间不足时, 才可能会回收它
- 弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。
- 虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。







---
###### 引用数据类型
引用类型本质就是通过指针, 指向堆中的对所持有的内存中间