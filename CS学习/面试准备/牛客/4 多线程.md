### 4.1 创建线程有哪几种方式

### 4.2 说说Thread类的常用方法
Thread类常用构造方法：
- Thread()
- Thread(String name)
- Thread(Runnable target)
- Thread(Runnable target, String name)
其中，参数 name为线程名，参数 target为包含线程体的目标对象。
- Thread类常用静态方法：
- currentThread()：返回当前正在执行的线程；
- interrupted()：返回当前执行的线程是否已经被中断；
- sleep(long millis)：使当前执行的线程睡眠多少毫秒数；
- yield()：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；
Thread类常用实例方法：
- getId()：返回该线程的id；
- getName()：返回该线程的名字；
- getPriority()：返回该线程的优先级；
- interrupt()：使该线程中断；
- isInterrupted()：返回该线程是否被中断；
- isAlive()：返回该线程是否处于活动状态；
- isDaemon()：返回该线程是否是守护线程；
- setDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线
程；
- setName(String name)：设置该线程的名字；
- setPriority(int newPriority)：改变该线程的优先级；
- join()：等待该线程终止；
- join(long millis)：等待该线程终止,至多等待多少毫秒数。

### 4.3 run() 和 start() 有什么区别
run()方法被称为线程执行体, 它的方法体代表了线程需要完成的任务, 而start()方法用来启动线程.调用start()方法启动线程时, 系统会把该run方法当成线程执行体来处理, 但如果直接调用线程对象的run方法, 将相当于在调用一个普通方法

### 4.4 线程是否可以重复启动, 会有什么后果
只能对处于新建状态的线程调用start方法, 否则会报异常;
###### 拓展阅读
当程序使用new关键字创建一个线程后, 该线程处于新建状态

### 4.5 介绍一下线程的生命周期
在线程的生命周期中, 它要经过新建, 就绪, 运行, 阻塞, 和死亡 5中状态, 尤其当线程启动以后, 它不可能一直"霸占"着cpu独自运行, 所以cpu需要在多条线程之间切换, 于是线程状态也会多次在运行, 就绪之间切换 
当程序使用new 关键字来创建了一个线程之后, 该线程就处于新建状态了, 此时它和其他java对象一样, 仅仅由JVM为其分配内存
当线程对象调用了start()方法之后, 该线程处于就绪状态, java虚拟机会为其创建方法调用栈和程序计数器, 处于这个状态中的线程并没有开始运行, 只是表示该线程可以运行了, 至于该线程何时开始运行, 取决于JVM线程调度器的调度
如果处于就绪状态的线程获得了CPU, 开始执行run()方法的线程执行体, 则该线程处于运行状态, 如果计算机只有一个cpu, 那么在任何时刻只有一个线程处于运行状态。当然，在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。
当一个线程开始执行后, 它不可能一直处于运行状态, 线程在运行过程中需要被中断, 目的是使其他线程获得执行机会, 线程调度的细节取决于平台所采用的策略. 对于采用抢占式策略的系统而言, 系统会给每个可执行的线程一个小时间段来处理任务。当该时间段用完后，系统就会剥夺该线程所占用=的资源，让其他线程获得执行的机会。当发生如下情况时，线程将会进入阻塞状态：
- 线程调用sleep()方法主动放弃所占用的处理器资源。
- 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
- 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。
- 线程在等待某个通知（notify）。
- 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。
针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：
- 调用sleep()方法的线程经过了指定时间。
- 线程调用的阻塞式IO方法已经返回。
- 线程成功地获得了试图取得的同步监视器。
- 线程正在等待某个通知时，其他线程发出了一个通知。
- 处于挂起状态的线程被调用了resume()恢复方法。
线程会以如下三种方式结束，结束后就处于死亡状态：
- run()或call()方法执行完成，线程正常结束。
- 线程抛出一个未捕获的Exception或Error。
- 直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。

### 4.6 如何实现线程同步
1. 同步方法: 使用synchronized关键字修饰的方法, 使用该方法前, 需要获得内置锁(每个对象都有一把), 否则就会处于阻塞状态. 需要注意的是如果, synchronized关键字也可以修饰静态方法, 此时如果调用该静态方法, 将会锁住整个类
2. 同步代码块: 就是有synchronized修饰的代码块, 被该关键字修饰的语句会自动加上内置锁, 从而实现同步
3. ReentrantLock: java5新增了一个java.util.concurrent包来支持同步, 其中ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。需要注意的是，ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。
4. volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。
5. 在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

### 4.7 说一说java多线程之间的通信
在java中线程通信主要有一下三种方式:
1. wait(), notify(), notifyAll(): 如果线程之间采用 synchronized 来保证线程安全, 则可以使用wait(), notify(), notifyAll() 来实现线程通信. 这3个方法是Object类中的方法. (当线程等待某个对象锁时, 应该通过这个对象来操作), 而且这三个方法都是本地方法, 而且被final修饰, 无法被重写.                                                                                                                     wait()方法可以让当前线程释放当前锁进入阻塞状态. notify() 方法用于唤醒一个正在等待相应对象锁的线程, 使其进入就绪队列, 以便在当前线程释放锁竞争锁, 进而得到CPU的执行. notifyAll() 用于唤醒所有正在等待相应对象锁的线程, 使它们进入就绪队列, 以便在当前线程释放锁后竞争锁, 进而得到cpu的执行                                                                                      每个锁对象都有两个队列, 一个是就绪队列, 一个是阻塞队列. 就绪队列存在了已就绪(将要竞争锁)的线程, 阻塞队列存储了被阻塞的线程. 当一个阻塞队列被唤醒后, 才会进入就绪队列, 进而等待cpu的调度. 反之, 当一个线程被wait后, 就会进入阻塞状态, 等待被唤醒  
2. await(), signal(), signalAll(): 如果线程之间采用Lock来保证线程安全, 则可以使用await(), signal(), signalAll来是西安线程通信. 这3个方法都是Condition接口中的方法, 该接口是在java 1.5中出现的, 它用来代替传统的wait + notify实现线程间的协作, 它的使用依赖Lock. 相比较于wait + notify, 使用Condition的await + signal这种方式能够更加安全和高效地实现线程间的协作                                                                                                                                                                          Condition依赖Lock接口, 生成一个Condition的基本diamagnetic是lock.newConditon(). 必须要注意的是, Condition 的 await()/signalAll()使用都必须在lock保护之内, 也就是说, 必须在lock.lock() 和 lock.unlock之间才可以使用. 事实上,await() / signalAll() / signal() 有着天然的对应关系. 即: Condition 中 的 await() 对应Object的wait(), Condition中的signal对应Object的notify()，Condition中的signalAll()对应Object的notifyAll()。
3. BlockingQueue: java5 提供了一个BlockingQueue接口, 虽然BlockingQueue也是Queue的子接口, 但它的主要作用并不是容器, 而是作为线程的通信工具. BlockingQueue具有一个特征: 当生产者线程试图BlockingQueue中取出元时间, 如果队列已空, 则该线程被阻塞

### 4.8 说一说Java同步机制中的wait和notify
wait(), notify(), norifyAll() 用来实现线程之间的通信, 这三个方法都不是Thread类中申明的方法, 而是Object类中声明的方法. 原因是因为锁是每个对象内置的, 所以和锁相关的操作当然是通过对象来操作


### 4.9 说一说sleep() 和 wait()
1. sleep() 是 Thread类中的静态方法, 而wait() 是Object类中的成员方法
2. sleep() 可以在任何地方使用, 而wait只能在同步方法或同步代码块中使用2
3. sleep()不会释放锁, 而wait()会释放锁, 并需要通过notify() / notifyAll 重新获得锁

### 4.10 说一说notify(), 和 notifyAll()的区别
-  notify(): 用来唤醒一个正在等待相应锁对象的线程, 使其进入如就绪队列, 以便在当前线程释放锁后竞争锁, 进而得到cpu的执行
-  norifyAll(): 用于唤醒所有正在等待响应对象锁的线程, 使它们进入就绪队列, 以便在当前线程释放锁后竞争锁, 进而得到cpu的执行

### 4.11 如何实现子线程先执行, 主线程再执行
子线程启动后, 在主线程中调用子线程的join方法;

### 4.12 阻塞线程的方式有哪些
发生如下情况时, 线程就会进入阻塞状态
- 线程调用sleep()方法主动放弃所占用的处理器资源
- 线程调用了一个阻塞方式IO方法, 在该方法返回之前, 该线程被阻塞
- 线程视图获得一个同步监视器, 但该同步监视器正在被其他资源所持有
- 线程在等待某个通知(notify)
- 程序调用了线程的suspend()方法将该线程挂起, 但这个方法容易导致死锁, 所以应该尽量避免使用该方法

### 4.13 说一说synchronized与Lick的区别

### 4.14 说一说synchronized的底层实现原理

### 4.15 synchronized可以修饰静态方法和静态代码块吗？
synchronized可以修饰静态方法，但不能修饰静态代码块。
### 4.16 谈谈ReentrantLock的实现原理

### 4.17 如果不使用synchronized和Lock，如何保证线程安全？

### 4.18 说一说Java中乐观锁和悲观锁的区别
- 悲观锁: 总是设想最坏情况, 每次去拿数据的时候都认为被人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿到这个数据就会阻塞直到它拿到锁, java中悲观锁是通过synchronized关键字 和 Lock接口来实现的
- 乐观锁: 顾名思义, 就是很乐观, 没次拿到数据的时候都认为别人不会修改, 所以每次不会上锁, 但是在更新的时候会判断一下在次期间别人有没有去更新这个数据. 乐观锁适合于多读的应用类型, 这样可以提高吞吐量. 
### 4.19 公平锁与非公平锁是怎么实现的？

### 4.20 了解Java中的锁升级吗

### 4.21 如何实现互斥锁（mutex）？

### 4.22 分段锁是怎么实现的？

### 4.23 说说你对读写锁的了解
与传统锁不同的是读写锁的规则是可以共享读, 但只能一个写, 总结起来: 读读不互斥,  读写互斥, 写写互斥, 而一般的独占锁是: 读读互斥, 读写互斥, 写写互斥


### 4.24 volatile 关键字有什么用
1. 保证可见性: 当一写volatile变量时, jvm会把线程本地内存中的变量强制刷新到主内存中去, 这个写操作会导致其他线程中的volatile变量缓存无效
2. 禁止指令重排: 使用volatile关键字修饰共享变量可以禁止`指令重排`

### 4.25 谈谈volatile的实现原理


### 4.29 介绍下ThreadLocal和它的应用场景

ThreadLocal 就是`线程私有的局部变量存储器`, 可以理解成每个线程专属的存储容器, 它用来存线程的私有变量, 它底层是map实现的, 通过set和get方法来存取值
ThreadLocal经典的使用场景是`为每个线程分配一个 JDBC 连接 Connection`，这样就可以保证每个线程
的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的
Connection。 另外ThreadLocal还经常用于`管理Session会话`，将Session保存在ThreadLocal中，`使线
程处理多次处理会话时始终是同一个Session。`

### 4.31 介绍一下线程池
因为涉及到与操作系统交互, 所以启动线程的成本比较高, 线程池就是解决这种问题的, 线程池里管理这大量线程, 
每次需要线程来完成任务时, 将Runnable连体或Callable实体传给线程池, 线程池为其分配线程来完成他的任务, 完成后不会结束进程, 而是返回线程池变为空闲状态

### 4.32 介绍一下线程池的工作流程
1. 判断核心线程是否已满, 没满则创建一个新的工作线程来执行任务
2. 满了就看任务队列满没满, 美满将其放入任务队列
3. 满了就看线程池满没满, 没满创建新的线程来执行任务
4. 满了, 就拒绝任务

### 4.32 介绍一下线程池的工作流程
线程池一共有5种状态:
1. RUNNABLE: 能接受新提交的任务, 并且也能处理阻塞队列中的任务
2. SHUTDOWN: 关闭状态, 不能接受新提交的任务, 但却可以继续处理阻塞队列中保存的任务.
3. STOP: 完全不处理任务了, 任务队列中的也不执行
4. TIDYING: 如果没有任务了, 有效线程数也为0了
5. 在TIDYING状态调用在terminated() 方法执行完后进入该状态

### 4.34 谈谈线程池的拒绝策略
当任务队列满了, 线程池也满了就睡采取任务拒绝策略
有四种策略:
1. AbortPolicy: 丢弃任务并抛出异常
2. Discord: 丢弃任务但不抛异常
3. DiscardOldestPolicy: 丢弃队列最前面的任务, 然后重新尝试执行任务执行任务
4. CallerRunPolicy: 由调用线程处理该任务

### 4.35 线程池的队列大小你通常怎么设置
1. cpu密集型任务: 尽量使用较小的线程池, 一般未cpu核心数 + 1. 因为cpu密集型任务使得cpu使用率很高, 若开过多的线程数, 会造成cpu过度使用
2. io密集型: 可以使用稍微大的线程池, io密集型任务cpu使用率低, 因此可以多开线程让cpu在等待io的时候处理其他任务


### 4.36 线程池有哪些参数，各个参数的作用是什么？
1. corePoolSize: 核心线程数, 当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时。
2. maximumPoolSize: 最大线程数
3. keepAliveTime（多余线程存活时间）
4. workQueue: （队列）：用于传输和保存等待执行任务的阻塞队列
5. threadFactory: 线程创建工厂
6. handler: 拒绝策略


