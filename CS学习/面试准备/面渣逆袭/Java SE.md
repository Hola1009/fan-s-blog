1. 什么是 java
   Java 是一门面像对象的高级语言, 他结合了c++的很多优点, 但是摒弃了 c++ 中比较容易出错的地方, 比如 垃圾回收, 同时 Java 也是 一门 跨平台的语言, 即一次编译, 到处运行, 只需要在 特定的平台 安装 特定的虚拟机即可

2. 什么时候开始学 Java
   我是从大一下学期开始学习 Java 的, 当时我刚学完 C 语言, 比较迷茫, 我的一个高中同学就建议我学习 Java, 于是, 我了解到绝大多数的互联网公司都是用 Java 开发的, 而且Java的学习生态非常强大, 就业岗位和薪资待遇都比较理想, 于是就想着一边学习, 一边实战, 于是便有了我的这几个项目

3. 平时用什么编程语言?
   我大一上学期学的是C语言, 大一下就开始学 Java 了, 开始做项目时发现自己的前端太薄弱了, 于是也对 Js, Vue, 
   react 进行了学习

4. 平时是怎么学习 Java 的
   我一开始是跟着B站上一个Java基础教程入的门, 后来感觉我得实际应用一下, 于是我便开始找项目做, 后来看别人的源码, 发现全是一些看不懂的 Spring 的代码, 然后我就又在 B站 和 Github找一些优质的视频资源和开源知识库来进行学习, 一边学一边去理解之前看不懂的代码, 看懂后呢, 我又开始去理解原理, 我再仔细把项目的业务逻辑梳理一遍, 然后再尝试去自己 做.

5. Java 语言有哪些优点?
   Java 有很多优秀的特点, 我列举下几个突出的,   面向对象, 跨平台, 支持多线程, 编译与解释并存
   1. 面向对象 (封装, 继承, 多态)
   2. 跨平台性, 具体体现在, Java 是 "一次编写 到处运行" 的语言, 因此采用 Java 程序具有很强的可移植性, 这一点是由 Java 虚拟机来提供保障的, 引入虚拟机后, Java语言在不同的平台上不需要重新编译
   3. 支持多线程, c++ 语言没有内置的多线程, 因此必须调用操作系统的多线程功能来进行多线程程序设计, 而Java语言却提供了多线程支持
   4. 支持 JIT 编译. JIT 是 Just-In-Time 的缩写, 就是即时编译器, 它可以在程序运行时将字节码转换成为本地机器码来提高程序运行速度

6. JVM, JDK 和 JRE 有什么区别
   1. JVM: Java Virtual Machine 的缩写, 即 ava虚拟机, 是 Java 实现跨平台的保障, 针对不同的操作系统, 有不同的 JVM **实现**, JVM 负责将 Java 字节码 转换成为特定平台的机器码, 并执行
   2. JRE: Java Runtime Environment, 也就是 Java 运行时环境, 包含了运行 Java 程序必须的库, 以及 Java 虚拟机
   3. JDK: Java Development Kit, 是一套完成的 Java SDK (软件开发工具), 包含 JRE 以及 编译器 javac, Java 文档生成工具 (Javadoc), Java 调式器等开发工具, 为开发者提供了开发, 编译, 调试 Java 程序的一整套环境


### part 2
1. 说说什么是跨平台性, 原理是什么?
所谓跨平台性，是指 Java 语言编写的程序，一次编译后，可以在多个系统平台上运行。

实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 java 程序。

2. 什么是字节码? 采用字节码的好处是什么?
所谓的字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。
只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性, 所以字节码好处就是Java为跨平台性的带来保障.

3. 为什么说Java语言"编译与解析并存"?
这与Java的跨平台性有关, 为了保障跨平台性, java源码会先被编译成字节码, 然后再由不同平台上的对应的虚拟机一行一行解析成机械码执行. 

4. java 又哪些数据类型
Java 的数据类型分两种：**基本数据类型**和**引用数据类型**。
基本数据类型可以分为3中: 字符型, 布尔型, 数值型

### part 3
1. 自动类型转换, 强制类型转换? 看看这几行代码?
   将数值范围小的数赋值给数据类型大的变量, 将自动转换, 但反过来不行, 需要强制类型转换.

2. 什么是自动拆箱/装箱？
- **装箱**：将基本数据类型转换为包装类型（Byte、Short、Integer、Long、Float、Double、Character、Boolean）。
- **拆箱**：将包装类型转换为基本数据类型。

3. &和&&有什么区别？
&运算符有两种用法：`短路与`、`逻辑与`。

4. switch 是否能作用在 byte/long/String 上？
   Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。
   从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。
   从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的
   
   5. break ,continue ,return 的区别及作用？
	- break 跳出整个循环，不再执行循环(**结束当前的循环体**)
	- continue 跳出本次循环，继续执行下次循环(**结束正在执行的循环 进入下一个循环条件**)
	- return 程序返回，不再执行下面的代码(**结束当前的方法 直接返回**)

6. 用最有效率的方法计算 2 乘以 8？
将2右移3位, 因为2x8相当于2的3次方

7. 说说自增自减运算？看下这几个代码运行结果？
就是对某个变量或数值进行+1或-1操作, 如果++放在前面, 这个表达式的结果就是原来变量+1后的值, 如果放在后面就是原来变量的值.

8. float 是怎么表示小数的?
   `float`类型的小数在计算机中是通过 IEEE 754 标准的单精度浮点数格式来表示的。
   单精度浮点数占用 4 字节（32 位），这 32 位被分为三个部分：符号位、指数部分和尾数部分。
   
   使用浮点数时需要注意，由于精度的限制，进行数学运算时可能会遇到舍入误差，特别是连续运算累积误差可能会变得显著。
   对于需要高精度计算的场景（如金融计算），可能需要考虑使用`BigDecimal`类来避免这种误差
9. 讲一下数据准确性高是怎么保证的？
   在金融计算中，保证数据准确性有两种方案，一种使用 `BigDecimal`，一种将浮点数转换为整数 int 进行计算。
   不能用浮点型的原因是会有精度问题.

### part 3
1. 面向对象 和 面向过程 的区别
- **⾯向过程** ：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以
- **⾯向对象** ：面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。
换句话说，面向过程以问题中的动词为切入点。面向对象以问题的主语和宾语为切入点。

面向过程强调的是功能行为，以函数为最小单位，考虑怎么做。
面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
面向过程的分析主体为解决问题的行为步骤，面向对象的分析主体为问题中的行动执行者和被执行者。

面向过程 故名思意 关注的时过程, 以函数为最小单位, 
面向对象 关注的是对象的属性和行为, 以类或对象为最小单位
面向过程的思维方式 切入点是动作, 要求分出一个个步骤, 用一个个函数实现
而面向对象的思维方式 切入点是 这个动作 是有哪些实体发生的, 这些实体又有哪些属性和行为.

接下来，以一个经典的例子进行说明。
例：人把大象关进冰箱。

面向过程的分析过程：
第一步：把冰箱门打开；
第二步：将大象放进冰箱；
第三步：把冰箱门关闭；
面向对象的分析过程：
第一步：分析动作是由那些实体发出的；
//人 ，冰箱，大象
第二步：定义主体，为其增加属性和功能；
//人，人需要有打开关闭冰箱，及将大象放入冰箱的功能；
//冰箱，冰箱需要具有能开门和关门的属性；
//大象，大象需要具有能够进入冰箱的功能


面向过程关注的是 动作, 而面向对象关注的是 对象 以及其所具有的属性和行为.
所以思考问题时, 面向过程以动作为切入点, 把一件事分为一个个步骤用一个个函数实现, 然后调用
而面向对象, 则是以对象, 以及它所具有的属性为切入点, 在分析问题时首先考虑的就是这个事件由哪些实体对象组成, 然后定义出实体, 为其增加属性和功能. 然后组织事件的时候, 就是要创建出对象, 然后调用他们的属性和方法来编写代码.

2. 面向对象有哪些特性? 
   封装 继承 多态
   封装是什么?
   封装是指将属性和方法捆绑在一起, 形成一个独立的对象.
   
   继承是什么?
   继承允许一个子类继承父类的属性和方法, 提高代码的复用性, 建立类与类之间的关系.
   
   什么是多态?
   就是方法的多样性, 同一种行为有不同的结果, 因为程序在运行时是根据运行时类型去调用方法的, 而子类是被允许重写父类方法的, 所以就会造成方法的多样性也就是多态.

3. 多态解决了什么问题?
   **多态的目的是为了提高代码的灵活性和可扩展性**，使得代码更容易维护和扩展。比如说动态绑定，允许在程序在运行时再确定调用的是子类还是父类的方法。运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是 Java 的方法调用机制能找到正确的方法体，然后执行，得到正确的结果。

4. 重载和重写的区别?
   同一个类中参数表不同的同名方法, 就是重载, 之所以同名是提高程序可读性.
   子类继承父类的方法就是重写, 重写方法的参数表必须与父类中的方法相同.

5. 什么是里氏代换规则?
   其规定, 任何父类可以出现的地方子类一定可以出现

6. 访问修饰符 public, private, protected, 默认 的区别
   public: 多有类可见
   private: 只有在同一个类中可见
   protected: 同一个包可见和所有子类可见
   默认: 同一个包类可见

7. this 关键字有什么作用?
   直接使用代表对象本身
   使用 this.属性 与 同名形参 做区别
   调用本类的构造方法

8. 抽象类和接口的区别?
   一个类只能继承一个抽象类, 但却可以实现多个接口
   抽次类有构造方法, 接口没有
   
   接口可以继承吗? 
   可以, 接口可以被接口继承
   
   继承和抽象的区别?
   继承是让子类可以重用父类的代码
   而抽象就是隐藏复杂性只显示重要的技术
   
   抽象类和普通类的区别?
   使用的关键字不同
   抽象类不能被实例化?
   抽象类中可以同时有普通方法和抽象方法

### part 4
1. 成员变量与局部变量的区别有哪些
   A:在类中的位置不同
   成员变量：在类中方法外
   局部变量：在方法定义中或者方法声明上
   
   B:在内存中的位置不同
   成员变量：在堆内存
   局部变量：在栈内存
   
   C:生命周期不同
   成员变量：随着对象的创建而存在，随着对象的消失而消失
   局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
   
   D:初始化值不同
   成员变量：有默认初始化值
   局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。


2. 静态变量和实例变量的区别？
   静态变量属于类, 实例变量属于对象, 静态变量 是通过 类名.属性名 访问, 而实例变量是通过 对象名.属性名 访问

3. final 关键字有什么作用?
   被final修饰的类不可以被继承, 被其修饰的变量不可以被重新赋值, 被其修饰的方法不可以被重写

4. final, finally, finalize 的区别?
   final是一个修饰符, finally 是 Java 中异常处理的一部分, finalize 则是一个类.
   
5. == 和 equals 的区别?
   什么是 hashCode 方法?
   他的作用是获取哈希码, 它会返回一个int的整数
   
   为什么要有 hashCode 方法?
   它通常是不会重复的, 可以用来做键值对中的键, 提高查询效率
   
   为什么重写equals时必须重写hashCode方法?
   因为他们之间的联系很重要, 哈希集合类就是依赖这一点来正确检索和检查对象.
   如果重写了 `equals()`方法而没有重写 `hashCode()`方法，那么被认为相等的对象可能会有不同的哈希码，从而导致无法在集合中正确处理这些对象。
   
   为什么两个对象具有相同的哈希值, 但是他们的值不一定相等?
   因为存在哈希冲突
   由于哈希函数将一个较大的输入域映射到一个较小的输出域，不同的输入值（即不同的对象）可能会产生相同的输出值（即相同的哈希码）
   
   
6. java 是值传递还是引用传递
   是值传递
   当一个对象被作为参数传递到方法中时，参数的值就是该对象的引用。引用的值是对象在堆中的地址。
   对象是存储在堆中的，所以传递对象的时候，可以理解为把变量存储的对象地址给传递过去。

7. 说说深拷贝和浅拷贝?
   浅拷贝的时候, 拷贝的属性和原对象完全相同, 基本数据类型拷贝值, 引用数据类型拷贝地址.(实现Cloneable接口并调用clone()方法)
   深拷贝的时候, 会递归复制所有的引用对象, 确保新对象与原对象互不影响 (手动拷贝, 或者使用序列化和反序列化)
   

8. Java 创建对象有哪几种方式?
   使用new关键字
   用反射机制创建
   克隆机制创建
   序列化机制创建
   
9. new子类的时候, 子类和父类静态代码块, 构造方法的执行顺序
   先父类静态代码块
   再试子类的静态代码块
   然后是父类的构造方法
   最后执行子类的构造方法

10. String 是 Java 基本数据类型吗? 可以被继承吗?
    String是基本数据类型吗
    不是 它是一个类, 属于引用类型
    
    string可以被继承吗?
    不行, 他被 final 修饰类
    
    String有哪些常用方法
    我自己常用的有:
    length() - 返回字符串长度
    charAt()
    subString()
    cantains()
    indexOf()
    replace()
    trim()
    split()

11. String 和 StringBuilder, StringBuffer 的区别?
    String是不可变的, 当需要处理大量字符串拼接, 就用StringBuilder, 它不会产生很多新的对象. 
    
    请说说String的特点
    String 是不可变的, 每次对String对象进行修改操作, 实际上会生成一个新的String对象.
    
    请说说StringBuilder的特点
    StringBuilder 提供了一系列的方法进行字符串的增删改查操作, 这些操作都是直接在底层数组进行的, 而不是生成新的 String 对象.
    
    请说说StringBuffer?
    他和StringBuilder类似但是, 它是线程安全的.
    
    请说说他们各自的使用场景
    String 适用于字符串内容不会变的场景
    StringBuilder 适用于单线程下需要频繁修改字符串内容的场景
    StringBuffer 现在不咋用了, 适用于多线程下频繁修改字符串内容


12. String str1 = new String("abc") 和 String str2 = "abc" 的区别
    直接使用双引号为字符串赋值, java会先到常量池中去找有没有这个内容的字符串, 没有就创建一个, 然后引用.
    如果使用 new 的方式的化, 也会在 常量池中 检查一遍, 没有相同内容的就创建一个, 接着会在队中常见一个新的字符串对象, 并将其初始化为常量池中字符串的副本
    
    new String("abc") 创建了几个对象
    1个或者两个.
    
13. String 是不可变 


14. Object 类的常见方法?
![Object类常见的方法|500](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-21.png)


对象比较的有 hashCode 和 equals 
对象拷贝的有 clone
对象转字符串的有 toString
多线程调度的有 wait notify notifyAll
反射的有 getClass
垃圾回收的的有 finalize


15. Java中异常处理体系
`Throwable` 是 Java 语言中所有错误和异常的基类。它有两个主要的子类：Error 和 Exception，这两个类分别代表了 Java 异常处理体系中的两个分支。

Error 类代表那些严重的错误，这类错误通常是程序无法处理的。比如，OutOfMemoryError 表示内存不足，StackOverflowError 表示栈溢出。这些错误通常与 JVM 的运行状态有关，一旦发生，应用程序通常无法恢复。

Exception 类代表程序可以处理的异常。它分为两大类：编译时异常（Checked Exception）和运行时异常（Runtime Exception）。

①、编译时异常（Checked Exception）：这类异常在编译时必须被显式处理（捕获或声明抛出）。

如果方法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在方法声明中用 throws 子句声明它，那么编译将不会通过。例如：IOException、SQLException 等。

②、运行时异常（Runtime Exception）：这类异常在运行时抛出，它们都是 RuntimeException 的子类。对于运行时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出）。

运行时异常通常是由程序逻辑错误导致的，如 NullPointerException、IndexOutOfBoundsException 等。


16. 异常的处理方式
![异常的处理方式](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-23.png)

针对异常的处理主要有两种方式：
- **遇到异常不进行具体处理，而是继续抛给调用者 （throw，throws）**
抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。

throws 用在方法上，后面跟的是异常类，可以跟多个；而 throw 用在方法内，后面跟的是异常对象。

- **try catch 捕获异常**

在 catch 语句块中补货发生的异常，并进行处理。
try-catch 捕获异常的时候还可以选择加上 finally 语句块，finally 语句块不管程序是否正常执行，最终它都会必然执行。

17. Java 中 的 IO 流分为几种?
流的分类可以根据多个维度进行, 根据流的方向可以分为输入流和输出流, 根据处理的数据单位可以分为字节流和字符, 该可以根据流的功能以及是否支持随机访问等来分类, 根据流的功能可以分为 节点流, 处理流 和管道流

18. IO 流用到了什么设计模式?
装饰器模式

19. Java 缓冲区溢出, 如何预防
合理设置缓冲区的大小
控制写入的信息量

20. 既然后裔字节流, 为什么还要有字符流?
其实字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还比较耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。

所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到文本存储的话使用字符流比较好


21. 文本存储是字节流还是字符流，视频文件呢？
在计算机中，文本和视频都是按照字节存储的，只是如果是文本文件的话，我们可以通过字符流的形式去读取，这样更方面的我们进行直接处理。

因此，无论是文本文件还是视频文件，它们在物理存储层面都是以字节流的形式存在。区别在于，我们如何通过 Java 代码来解释和处理这些字节流：作为编码后的字符还是作为二进制数据。

22. BIO, NIO, AIO 之间的区别?



23. 什么是序列化? 什么是反序列化?
序列化是指将对象转为字节流的过程, 以便能够将对象保存到文件, 数据库, 或者进行网络传输.
反序列化就是将字节流转换会对象的过程, 以便构建原始对象

24. Serializable 接口有什么用?
用于表欧猪一个类可以被修恶化

25. serialVersionUID 有什么用?
serialVersionUID 是 Java 序列化机制中用于标识类版本的唯一标识符。它的作用是确保在序列化和反序列化过程中，类的版本是兼容的。

26. 序列化不包含静态变量吗?
对的, 序列化机制只会保存对象的状态, 而静态变量属于类的状态

27. 如果有些变量不想序列化, 怎么办
可以使用 transient 关键字修饰不想被序列化的变量

28. 说说有几种序列化的方式?

Java 序列化的方式有: Java 对象流序列化, Json序列化, ProtoBuff序列化
- java 对象流序列化: Java原生序列化方法即通过 Java 原生流1的方式进行转换, 一般是对象鼠槌路和对象输入流
- Json 序列化: 这个是我们最常用的序列化方式, Json 序列化的方式很多, 一般使用jackson包, 通过 ObjectMapper 类进行一些操作, 比如将对象转化成byte数组或者将json转成为对下个
- ProtoBuff 序列化: ProtocolBuffer 是一种轻便高效的结构化数据存储格式, ProtoBuff 序列化对象可以很大程度上将其压缩, 可以大大减少数据传输大小, 提高系统性能.

### part 5
1. Java 泛型了解么? 什么是类型擦除? 介绍一下常用的通配符?
Java 泛型 是 JDK 5 引入的一个新特性, 泛型提供了编译时类型安全检测机制, 该机制允许程序在编译时检测到非法的类型. 泛型本质上是参数化类型, 也就是说操作的数据类型被指定为一个参数.

泛型是将类型参数化, 将操作的数据类型指定为一个参数, 编译时如果发现非法类型就会报错.

泛型一般有三种使用方式: 泛型类, 泛型接口, 泛型方法

泛型常用的通配符有拿下?
常用的通配符为: T, E, K, V, ? 
- ? 表示不确定的 Java 类型
- T 表示具体的一个Java 类型
- k v 代表键值对
- e 代表 Element

什么是泛型擦除?
Java 的泛型是伪泛型, 在编译期间, 所有的类型信息都会被擦掉
也就是说在运行的时候是没有泛型的.
为什么要泛型擦除?
因为在JDK5之前是没有泛型的,为了让JVM向下兼容, 就出了类型擦除这个策略

2. 说一说你对注解的理解?
**Java 注解本质上是一个标记**，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。
注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。
有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。

例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。
注解的生命周期有3大类, 分别是:
- RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件
- RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了
- RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息


再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以**在运行的时候可以通过反射得到注解的信息**，还能拿到标记的值 required 。


3. 什么是反射? 应用? 原理
创建一个对象是通过 new 关键字来实现的，比如：
Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。

反射功能主要通过 `java.lang.Class` 类及 `java.lang.reflect` 包中的类如 Method, Field, Constructor 等来实现。

反射功能主要通过 `java.lang.Class` 类及 `java.lang.reflect` 包中的类如 Method, Field, Constructor 等来实现。

反射有哪些应用场景?
①、Spring 框架就大量使用了反射来动态加载和管理 Bean。
②、Java 的动态代理（Dynamic Proxy）机制就使用了反射来创建代理类。代理类可以在运行时动态处理方法调用，这在实现 AOP 和拦截器时非常有用。

4. JDK1.8 都有哪些新特性?
比如 Lambda 表达式, 接口默认方法, Stream APi, 日期时间 API, Optional类等

Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。

 Stream 是对 Java 集合框架的增强，它提供了一种高效且易于使用的数据处理方式。

Java 8 引入了一个全新的日期和时间 API，位于`java.time`包中。这个新的 API 纠正了旧版`java.util.Date`类中的许多缺陷。

引入 Optional 是为了减少空指针异常。



5. Lambda 表达式了解多少
Lambda 表达式主要用于提供一种简洁的方式来表示匿名方法，使 Java 具备了函数式编程的特性。\

所谓函数式编程, 就是把函数作为参数传递给方法, 或者作为方法的返回结果

6. Optional 了解吗
Optional 是用来防范空指针异常的

可以将 `Optional` 看做是包装对象（可能是 `null`, 也有可能非 `null`）的容器。当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 `Optional` 来包装它，这也是在 Java 8 被推荐使用的做法。

7. Stream 流用过吗?
Stream 流, 简单来说, 对一个包含元素的集合做各种操作。这些操作可能是 _中间操作_ 亦或是 _终端操作_。 终端操作会返回一个结果，而中间操作会返回一个 `Stream` 流。
![|600](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/javase-38.png)