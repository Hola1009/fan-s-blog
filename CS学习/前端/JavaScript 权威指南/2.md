## 循环语句
| 特性       | `for...in` | `for...of`        |
| -------- | ---------- | ----------------- |
| **目的**   | 遍历对象的属性/键  | 遍历可迭代对象的值         |
| **使用场景** | 主要用于对象和数组  | 最适用于数组、字符串、映射、集合等 |
| **输出类型** | 键（字符串）     | 值（元素）             |
| **性能**   | 对于大型集合较慢   | 通常对数组/迭代对象更快      |
> [! tip] 对象默认是不可迭代的

Map则比较有意思，因为Map对象的迭代器并不迭代Map键或Map值，而是迭代键/值对。每次迭代，迭代器都会返回一个数组，其第一个元素是键，第二个元素是对应的值。给出一个Map m，可以像下
面这样迭代和解构其键/值对：

## 跳转语句
### 语句标签
通过前置一个标识符和一个冒号，可以为任何语句加上标签：
![[Pasted image 20240925215829.png]]

### break 和 continue

break 和 continue 是JavaScript中唯一使用语句标签的语句，后面的小节会介绍它们。下面看一个给while循环加标签并通过continue语句使用这个标签的
例子：
![[Pasted image 20240925215910.png]]
当break后面跟一个标签时，它会跳转到具有指定标签的包含语句的末尾或终止该语句。
![[Pasted image 20240925220158.png]]


continue语句与break语句类似, 执行continue语句时，包含循环的当前迭代会终止，下一次迭代开始。对于不同类型的循环，结果可能有所不同。

对于for循环而言，`会先求值increment表达式`，并再次测试test表达式，以决定是否该进行下一次迭代。

但因为continue语句在这两种循环中的不同表现，所以不可能单纯使用while循环来模拟for循环。

### throw
和 Java 差不多, 语法如下, 解释器在抛出错误时会使用Error类及其子类，当然我们也可以在自己的代码中使用这些类。Error对象有一个name属性和一个message属性，分别用于指定错误类型和保存传入构造函数的字符
串。
![[Pasted image 20240925221127.png]]

#### 干捕获句子
我们偶尔会使用catch子句，只为了检测和停止异常传播
```js
method = () => {
  try {
    // 业务逻辑
  } catch {
    return undefined
  }
}
```
### with
书中建议不要用它, 那我就不学了

### debugger
可以用来停止程序, 搭配 if 使用可以用来调试程序
![[Pasted image 20240925222048.png]]

### use strict
只能出现在脚本或函数体的开头，位于所有其他真正的语句之前。
"use strict"指令的目的是表示（在脚本或函数中）它后面的代码是严格代码。

## 对象介绍
JavaScript使用术语“自有属性”指代非继承属性"。
除了名字和值之外，每个属性还有3个属性特性（property attribute）：

## 创建对象
对象可以通过对象字面量、new关键字和Object.create()函数来创建。接下来分别介绍这几种技术。

### 对象字面量
- 就是用一个花括号框住一些用逗号分割的键值对
- 对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。

![[Pasted image 20240925223112.png]]

### 使用 new 创建对象
和 Java 一样
![[Pasted image 20240925223414.png]]

###  原型
和 Java 父类有点像, 将就理解吧
几乎每个JavaScript对象都有另一个与之关联的对象。这另一个对象被称为原型（prototype），第一个对象从这个原型继承属性。

- 通过对象字面量创建的所有对象`都有相同的原型对象`
- 使用new关键字和构造函数调用创建的对象，使用构造函数 prototype 属性的值作为它们的原型
- 原型链: 例如:  Object.prototype => Date.prototype => new Date(), 这就是一条原型链

### Object.create()
也是用来创建对象的, 第一个参数是对象原型
如果传入的是 null, 这个对象将没有任何属性和方法

#### 一个作用场景
Js 在传递对象时采用的是引用传递, 所以为了防止对象被其他第三方库函数修改, 可以 使用 Object.create(对象), 这将传入一个继承自它的对象

## 查询和设置属性

### 作为关联数组的对象
![[Pasted image 20240925230310.png]]

第二种访问方式像是关联数组的方式, 关联数组说人话就是 map 

在通过 \[\] 来访问属性时, 因为 \[\] 里面是字符串, 所以可以在程序运行时修改, 像这样遍历访问有相同前缀的变量

![[Pasted image 20240925230635.png]]

这有一个很好的例子, 
例如，这个程序允许用户填写自己持有的每只股票的名字和数量。假设使用名为portfolio的对象
来保存这些信息，该对象对每只股票都有一个属性，其每个属性名都是股票的名字，而属性值是该股票的数量。因此如果一个用户持有50股IBM股票，则portfolio.ibm属性的值就是50。

说实话, 这就是 map 嘛, 只不过可以使用 \[ \] 进行访问, 使用起来很简单


## 声明
### import 和 export
import 和 export 搭配使用, 可以让不同js文件共享值(每个js代码文件的作用域都是单独的)

使用 import 需要在 `package.json` 中设置 type 属性, 或修改文件名后缀名为`.mjs`
```json
{
  "type": "module"
}
```

